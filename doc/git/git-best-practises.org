#+TITLE: Git Best Practises


#+begin_abstract
#+LaTeX: \noindent%
Tips and recommendations for using Git with the Pencil code.
#+end_abstract


* Operative Summary

  Here is the bottom line of this document.

  1. Decide whether you want to rebase or merge your local changes into
     upstream (typically the /origin/master/ branch).

     a. Rebase: Use '=git pull --rebase=' to get upstream changes into you
        local tracking branch (typically /master/).

     b. Merge: Do /not/ merge upstream into your tracking branch like this:
        #+BEGIN_SRC sh
        git merge origin/master  # DON'T!
        #+END_SRC
        because that breaks the SVN bridge and makes it quite difficult to
        understand the repository's topology.

        Instead, merge your changes into upstream, either manually or
        using '=git pc reverse-merge='.

  2. Think about using feature branches for logic units that cover more
     than a few commits.


* Prerequisites

  We need a few simple concepts for the discussion to follow.


** What is Git?

   Git is a flexible version-control system that is well-suited for
   software development, be it with a centralized server (Github, in our
   case), or in a completely decentralized setting.


** What is a Git repository?

   A Git repository is a set of unique commits that form a
   [[https://en.wikipedia.org/wiki/Directed_acyclic_graph][directed acyclic graph]] (DAG) like this:
   #+begin_example
     A---B---C---D---E---F--- master
          \     /     \
           F---G       H---I--- feature
   #+end_example

   We say that E is a /child/ of D, and that D has two
   /parents/, C and G.
   The /ancestors/ of D consists of A, B, C, F, and G.
   The /descendants/ of D are E, F, H, and I.

   If you know how to read this diagram, you know enough about DAGs for
   our purposes.[fn:1]


[fn:1]You get extra credits if you can answer the question “Which of the
   commits A, E and F belong to branch /feature/?”


*** What is a commit?

    A commit typically represents a state of the file tree (the directory
    tree you get by checking out a revision), together with its complete
    commit ancestry.
    So you get different commit ids (represented as hexadecimal SHA1 hash
    codes) if you
    - commit a change, commit the inverse of that change, and commit the
      original change again;
    - change the commit message of your last commit (with '=git commit
      --amend=');
    - take some part of the commit graph and attach it somewhere else
      ('=git rebase=');
    - make any change to a commit that is an ancestor of the commit in
      question.


** The different layers[?] of a Git repository's state

   1. Upstream [there could be several, but not for us]
   2. Tracking branch
   3. Index
   4. File system

   → Many combinations that can conflict
   But don't worry, it is not hard to sort them all out.


** Merging and rebasing

*** What is merging?
    <<Merge>>

    A /merge/ commit adds a new connection to parts of the Git graph.
    For example, if we have the following situation
    #+begin_example
      A---B---C--- master
           \
            F---G--- feature
    #+end_example
    and want to bring the changes from branch /feature/ to /master/, we
    can merge /feature/ into /master/ and get
    #+begin_example
      A---B---C---D--- master
           \     /
            F---G--- feature
    #+end_example

    In the pure DAG sense, the two parents C and G of the merge commit D
    are completely equivalent, but for reasons discussed [[below]], we want to
    make sure we merge /feature/ into /master/ (so C is the /first parent/
    and G is the /second parent/), not the other way around.


*** What is rebasing?
    <<Rebase>>

    In the example above, we have a second option to bring the feature
    branch's changes into master, by creating new commits that contain
    those changes:
    #+begin_example
      A---B---C---D---F'---G'--- master, feature
    #+end_example
    Immediately after this, both /master/ and /feature/ point to the same
    commit G', but this may change in the future, e.g.
    #+begin_example
      A---B---C---D---F'---G'---H--- master
                            \
                             I--- feature
    #+end_example

    Rebasing is not an exclusive option.
    Even if you routinely rebase your local changes, you will want to
    merge longer-lived feature branches.


*** Pros and cons

    Here is the decision matrix for merging vs. rebasing

    | Criterion                 | Merge        | Rebase           |
    |---------------------------+--------------+------------------|
    | Resulting graph structure | More complex | Simpler          |
    | History                   | Preserved    | Modified         |
    | Safety                    | Safer        | Less safe [fn:2] |

    In short, use merging when you are afraid – [[What to do when you think you're lost][but you needn't be afraid]].


[fn:2] Less safe in the sense that conflicts can cause you to end up
    in a detached-head state.


**** Graph structure

     Every merge commit increases the connectivity of the commit graph by
     one[fn:3].


[fn:3] Or even more than one, in the case of an /octopus merge/.
     But those are somewhat exotic.


**** Rewriting history

     In our rebase example above, the commits F and G were transformed
     into F' and G'.
     In the simplest case, both sets of commits represent exactly the same
     difference of the file tree.
     But if you had to fix conflicts, this is no longer the case, and you
     appear to have lost the original change G by pretending that you were
     applying a change G' in the first place.[fn:4]


[fn:4] But of course this is not true: you can use [[git reflog]]
     to go back to your original changes.
     And you should no longer be interested in the original change once
     the new version gets part of the Git narrative[?].


     Once you embrace the idea that you can change history, you can use it
     to write meaningful commit messages while you are in the right set
     of mind (i.e. /before/ you test your changes, because after testing
     it is harder to remember what you were doing in the first place).
     Or you can rewrite history to fix a recent commit (code and message),
     or to combine commits in order to get a more readable history.

**** The worst thing that can happen

     If you have conflicts, rebasing can bring your sandbox [explain that
     name, or use another word] into a state where you are not on any
     branch (/detached head/).
     This is not really something to worry about:
     Just fix the conflicts and do '=git rebase --continue=' to finish the
     rebase; and in case you get lost, do '=git rebase --abort=' and start
     afresh.
     Even if you get completely lost and resort to measures like
     '=git reset=', [[What to do when you think you're lost][you needn't be afraid]] to lose history.


* Best practices

** Don't merge upstream into your tracking branch
   [… except when it makes sense]

   Suppose you just started developing code on /master/.
   Your branches look like this (`A' and `B' are commits, the `o' is just
   a visual connector):
   #+begin_example
     --A---B-----  origin/master (remote branch)
            \
             o---  master (local tracking branch)
   #+end_example

   The tracking branch exists only on your local computer, and you modify
   it by adding commits, rebasing them, etc.

   The /remote branch/ also exists only on your computer.
   It represents what is known about a branch called /master/ on the
   server and serves for synchronization with the server.
   You cannot directly commit to this branch.

   \bigskip

   Now you commit some changes X, Y to your local tracking branch:
   #+begin_example
     --A---B----------  origin/master
            \
             X---Y----  master
   #+end_example
   and want to push them to the server.
   If the server is still at commit B, this will result in
   #+begin_example
     --A---B---X---Y-----  origin/master
                    \
                     o---  master
   #+end_example

   However, if somebody has committed changes to the server before you
   push, you will get an error message:
   #+begin_example
     To [...]
      ! [rejected]        master -> master (fetch first)
     error: failed to push some refs to [...]
   #+end_example
   followed by some explanatory text.

   Before you can fix the problem, you need to =git fetch= to update the
   remote branch:
   #+begin_example
     --A---B---C---D---E--  origin/master
            \
             X---Y--------  master
   #+end_example

   Your aim is to bring the two lines of development together, and you can
   either do this [[Rebase][using rebase]], or [[Merge][using merge]].

   Rebasing is straight-forward, you run
   #+begin_src sh
     git rebase origin/master
   #+end_src
   , if necessary deal with conflicts (that will temporarily throw your
   repository into a headless state) and end up with
   #+begin_example
     --A---B---C---D---E-----------  origin/master
                        \
                         X'---Y'---  master
   #+end_example
   You have changed your commits by turning them into descendants of E (and
   possibly by including solutions for conflicts) and you can now push to
   get
   #+begin_example
     --A---B---C---D---E---X'---Y'----  origin/master
                                 \
                                  o---  master
   #+end_example
   As you can see, this approach gives you a linear history similar to
   what you know from /Subversion/.

   Alternatively, we can merge the two branches together.
   It is tempting to just call (after the =git fetch=)
   #+begin_src sh
     git merge origin/master  # DON'T DO THIS
   #+end_src
   which would give you the following repository structure
   #+begin_example
     --A---B---C---D---E-----  origin/master
            \           \
             X-----Y-----M---  master
   #+end_example
   This doesn't look so bad, but when you push /master/, you will get
   #+begin_example
     --A---B---C---D---E---M----  origin/master
            \             / \
             X-----------Y   o--  master
   #+end_example

   Topologically, that is exactly what we want.
   But there is more to a git repository than pure topology of the
   directed acyclic graph: there is an order in parentage.
   Y is the /first parent/ of the merge commit M, while E is the /second
   parent/:[fn:5]
   #+begin_example
                         2
     --A---B---C---D---E---M-----  origin/master
            \             /1\
             X-----------Y   o---  master
   #+end_example
   This can be rearranged as
   #+begin_example
                     1
     --A---B---X---Y---M-----  origin/master
            \         /2 \
             C---D---E   o---  master
   #+end_example
   and indeed this is what many tools will show you.[fn:6]
   For example, commands like =gitk --first-parent= (or simply =git log
   --first-parent=), you give you
   #+begin_example
     --A---B---X---Y---M-----  origin/master
                \     / \
                         o---  master
   #+end_example
   which suggests that the main chain (= first-parent lineage) of commits
   on the server has disruptively changed from
   #+begin_example
     --A---B---C---D---E-----
   #+end_example
   to
   #+begin_example
     --A---B---X---Y---M-----
   #+end_example

   Given that the SVN bridge probably has to rely on first-parent lineage
   between commits, it is pretty obvious that such a reinterpretation
   leads to a new SVN repository structure that is not compatible with
   what we had before.
     Hence, it is not surprising that such merges cause troubles with the
   SVN bridge:
   #+begin_example
     $ svn commit <file>
     svn: E160024: Transmission failed (Details follow):
     svn: E160024: resource out of date; try updating
   #+end_example


[fn:5]My notation in the graph is adopted from
   [[http://git-blame.blogspot.de/2015/03/fun-with-non-fast-forward.html][this quite readable discussion]].


[fn:6]Including the [[https://github.com/pencil-code/pencil-code/network][GitHub network graph]], gitk (to some extent) and the
GitHub SVN bridge.


   \bigskip

   So is it really wrong to merge?
   Not if you merge the right way around.
   You need to create a merge commit where the latest upstream commit (E
   in our example) is the first parent, and the tracking-branch commit (Y)
   is the second parent.

   How to do this is left as an exercise to the reader.
   It is not very tricky, but for convenience we have a =git-pc= command
   #+begin_src sh
     git pc reverse-merge origin-master  # DO THIS INSTEAD
   #+end_src
   that gives you exactly the desired structure:
   #+begin_example
                         1
     --A---B---C---D---E---M-----  origin/master
            \             /2\
             X-----------Y   o---  master
   #+end_example

   Aside from problems with the SVN bridge, merging the right way around
   will also lead to a much more meaningful history.
   Consider the following real-life example:[fn:25]

   #+begin_example
   A   o           add new time step calculation for slope limited diffusion
   B   o           Added comments about which line will not work
   C   M─┐         Merge branch 'master' of https://github.com/pencil-code/pencil-code
   D   │ o         Revised data to account for correction to chi-therm
   B   │ o         Lets see if the new IO modules work everywhere as expected...
   D   │ M─┐       Merge branch 'master' of https://github.com/pencil-code/pencil-code
   B   │ │ o       We explicitly want to allow missing namelists
   D   │ M─│─┐     Merge branch 'master' of https://github.com/pencil-code/pencil-code
   A   │ │ o─┘     fixed some errors
   D   │ M─│─┐     Merge branch 'master' of https://github.com/pencil-code/pencil-code
   A   │ │ o─┘     removed some doubling of some subroutine
   A   │ │ o       more on slope limited diffusion
   E   │ │ M─┐     Merge branch 'master' of https://github.com/pencil-code/pencil-code Adding
   F   │ │ │ o     added Hill vortex rain as forcing
   B   │ │ │ M─┐   Finally fixed the last still broken autotest
   B   │ │ │ │ o   Finally fixed the last still broken autotest
   A   │ │ │ o │   More correction and additions for the slope limited diffusion,
   B   │ │ │ o─┘   Removed "array temporaries", see also 2a73f3cea323
   G   │ │ │ o     added a phase to enforced vertical shear profile;
   E   │ │ o │     Adding components of the current helicity tensor.
   D   │ o │ │     thermo hydrostatic equilibrium ISM still under construction
   C   o │ │ │     pc_meanfield_collect: Fixed some bugs and removed line writes
   #+end_example

   So, did users A, B and G really work on the same feature branch to add
   phase to the shear profile, remove array temporaries and to correct
   slope limited diffusion?
   And did those commits get merged in a commit that claims to have fixed
   the last broken autotest?

   The true story must have been something like this:
   #+begin_example
   A   o          add new time step calculation for slope limited diffusion
   B   o          Added comments about which line will not work
   C   M─┐        Merge one commit into master
   D   o │        Revised data to account for correction to chi-therm
   B   o │        Lets see if the new IO modules work everywhere as expected...
   D   M─│─┐      Third try at merging equilibrium in to master
   B   o │ │      We explicitly want to allow missing namelists
   D   │ │ M─┐    Second try at merging hydrostatic equilibrium into master
   A   o─│─┘ │    fixed some errors
   D   │ │   M─┐  First try at merging hydrostatic equilibrium into master
   A   o─│───┘ │  removed some doubling of some subroutine
   A   o │     │  more on slope limited diffusion
   E   M─│─┐   │  Merge current helicity tensor into master
   F   o │ │   │  added Hill vortex rain as forcing
   B   M─│─│─┐ │  Merge fix for last broken autotest
   B   │ │ │ o │  Finally fixed the last still broken autotest
   A   o │ │ │ │  More correction and additions for the slope limited diffusion,
   B   o─│─│─┘ │  Removed "array temporaries", see also 2a73f3cea323
   G   o │ │   │  added a phase to enforced vertical shear profile;
   E   │ │ o   │  Adding components of the current helicity tensor.
   D   │ │ │   o  thermo hydrostatic equilibrium ISM still under construction
   C   │ o │   │  pc_meanfield_collect: Fixed some bugs and removed line writes
   #+end_example
   with most of the development happening on the main line, but
   occasionally, somebody has a change that needs to get merged into that
   line, because other commits got pushed first.

   And indeed something like this is how =tig= would have drawn the graph,
   had all of the merges been from tracking-branch into upstream and not
   the other way around.


[fn:25]The output was obtained using =tig= on the Pencil Code repository,
removing many commits, shortening some commit messages and mildly
anonymizing the commits.


   \bigskip

   To summarize this section:
   /When developing on /master/, if you cannot directly push your changes
   due to upstream commits, either use /rebase/, or use /git pc
   reverse-merge/./

   Now consider the case where you have made local changes on your
   tracking branch and then =git fetch= finds that in parallel there have
   been changes on the server:
   #+begin_example
     --A---B---C---D---E--  origin/master (remote branch)
            \
             M---N---O------  master (local tracking branch)
   #+end_example


* Feature branches

  - When you are working on one topic and expect more than a
    handful[fn:7] of changes, consider using a /feature branch/.

  - When you are collaborating on a topic with somebody else and your
    changes are not yet ready for the others, use a feature branch.


[fn:7] Even just two or three commits may be enough to go for a feature
branch if that improves the narrative.


  To work with a feature branch, just go to the latest commit of /master/
  (the later you start the branch, the fewer conflicts you will create),

  #+begin_src sh
    git checkout master
    git pull --rebase
  #+end_src
  and create the branch
  #+begin_src sh
    git checkout -b cool-new-feature
  #+end_src

  \bigskip

  If that branch is long-lived, you will want to occasionally merge master
  into it:[fn:8]
  Run
  #+begin_src sh
    git fetch origin
    git stash  # if you have uncommitted local changes
  #+end_src
  to update your knowledge of the server's master branch.

  Then do
  #+begin_src sh
    git checkout master  # check out your local tracking branch …
    git pull --rebase    # … and bring it up to date

    git checkout cool-new-feature
    git merge master     # do the actual merge
  #+end_src
  There are some shorter variants to this procedure. You can use our
  `=git pc=' script like this:
  #+begin_src sh
    git pc ff-update master  # bring master up-to-date
    git merge master         # do the actual merge
  #+end_src
  or you could directly merge the remote branch
  #+begin_src sh
    git merge origin/master
  #+end_src
  although this is less common than merging the local tracking branch.

  After merging, don't forget to
  #+begin_src sh
    git stash pop
  #+end_src
  If you have stashed changes before you merged.

  \bigskip

  When your branch is ready for merging back, you do
  #+begin_src sh
    git checkout master
    git pull --rebase    # brin master up-to-date
    git merge cool-new-feature
    [test]
    git push
  #+end_src

  The topology now looks like this:
  #+begin_example
    --A---B---C---D---E---F---G---H---I---J---K-- master
       \               \             /
        N---O---P---Q---R---S---T---U             feature
  #+end_example

  \bigskip

  What if that push failed due to somebody committing new changes
  upstream?

  No problem.
  We tag the first merge attempt and merge that tag to the updated
  upstream branch:
  #+begin_src sh
    # remember, we are on master
    git push   # fails: "! [rejected] master -> master (fetch first)"

    git tag previous-merge-of-cool-new-feature
    git fetch                       # update origin/master
    git reset --hard origin/master  # update local master branch
    git merge previous-merge-of-cool-new-feature
    [test]
    git push
  #+end_src

  The narrative now says:
  We have tried to merge /cool-new-feature/ into master, but failed to
  push that, so we then merged that first merge into master and pushed.
  That may be more detail than we wanted (and more steps than we
  anticipated), but describes exactly what happened.

  #+begin_example
    --A---B---C---D---E----F-----G----H---I---J---K-- master
       \               \               \     /
        \               \               V---o
         \               \             /
          N---O---P---Q---R---S---T---U             feature
  #+end_example


  \bigskip


  (*More on feature branches from my email*)


[fn:8] This does not violate our rule
`[[Don't merge upstream into your tracking branch][don't merge upstream into your local tracking branch]]'
because the merge commit is on the branch and that makes perfect narrative
sense.


* Put this somewhere

** Advice against setting pull.rebase
        Or consider '=git config --global pull.rebase true=',
        /but remember to do so in every checkout and expect communication
        problems with others/.

** Use gitk (or '=tig=' or some variant of '=git log --graph=')


** Don't panic
   [[https://en.wikipedia.org/wiki/Phrases_from_The_Hitchhiker's_Guide_to_the_Galaxy#Don.27t_Panic][Don't panic]]
   [or /What to do when you think you're lost/]

   Git will try hard to preserve your changes:[fn:9]

   - Any changes you committed will be part of the [[git reflog][/reflog/]] for at least
     two weeks.[fn:10]

   - Uncommitted changes to git-controlled-files will only get overwritten
     if you run one of the commands
     - =git checkout <file-or-directory>=

   - Files unknown to Git will only get lost with
     - =git clean=
     - Again, any non-git commands that change files


[fn:9]There are corner cases where other git commands (like
   =git stash --include-untracked=) call commands like =git clean=, which
   can in principle [[http://blog.icefusion.co.uk/git-stash-can-delete-ignored-files-git-stash-u/][lead to data loss]].
   However, this should only concern files that match your =.gitignore=
   patterns, and if that is the case for any file you care about, you have
   been asking for trouble beforehand.


[fn:10]Unless you explicitly decide otherwise.


   Table \ref{Table:How-to-lose-changes} summarizes this discussion.

#+label: Table:How-to-lose-changes
#+caption: Scatter Plot with Regression Line
   | Changes                                     | How they can get lost                 |
   |---------------------------------------------+---------------------------------------|
   | Changes committed to git                    | Not at all, unless you insist [fn:11]  |
   |---------------------------------------------+---------------------------------------|
   | Uncommitted changes to git-controlled files | =git  t checkout <file-or-directory>= |
   |                                             | =git reset --hard=                    |
   |                                             | Non-git commands                      |
   |---------------------------------------------+---------------------------------------|
   | Files unknown to Git                        | =git clean=                           |
   |                                             | Non-git commands                      |


[fn:11] Leaving relevant Git commits dangling (≈ unused) for more than two
weeks counts as insisting on data loss.


*** I'm almost panicking because I'm afraid something got lost
    [… although I know this is not the case because I stayed away from the
    commands in Table \ref{Table:How-to-lose-changes}]

    Here is how to see almost every change[fn:12] that was ever[fn:13]
    known to git:
    #+begin_src sh
      gitk --reflog --all
      # or
      tig --reflog --all
      # or, without graphics,
      git reflog --all --glob='stash*'
    #+end_src

    If you want to also see dropped stashes, you can use
    #+begin_src sh
      git pc panic -v
    #+end_src


[fn:12] This will not show dropped stashes or stashes older than the last one.


[fn:13] Redefining “ever” = “in the last two weeks” for dangling commits.


   2. <<git reflog>>'=git reflog=' [plus stash] or '=gitk --reflog='
      or '=git pc reflog [-v]='

      Discuss garbage collection:
      Removes old changes that nobody [no commit] is interested in any
      more.
      Unless you deliberately dropped commits, there will be some other
      form of those commits in the perpetual history, and after two weeks
      you wouldn't remember anyway what you thought when writing the first
      version.

** Narrative
   - Telling a story.
     There are several styles of telling stories:
     - Always merge :: chronicler/diary style.
          Include all the nitty-gritty details, failed attempts, etc.
     - Rebase :: letter/novelist style.
          Bring facts into a logical frames and order them

** Why no automatic pull-the-push

   - Integrity: this is a version that has not existed before
     [Hmm, =svn update= does just the pull part, what you push [commit] is
     what you have in your file system.
     Still, pulling in changes may put your working copy into some strange
     state that git can only represent as /detached head \{true?\} …]


** What to avoid

   - Rewrite history that is already on the server
     - Certainly so if it is on /master/
     - But even feature branches can get merged into master

   - Don't push your personal tags [but not so important, we can delete
     them later]


* To do:
  - gitk: How to show unadded files?


* Org configuration                                   :noexport:ARCHIVE:

#+AUTHOR: Wolfgang Dobler
#+EMAIL:
#+DESCRIPTION:
#+KEYWORDS:
#+LANGUAGE: en

##+STARTUP: content
#+STARTUP: showall

##+ARCHIVE: ::* Archive

#+DRAWERS: HIDDEN PROPERTIES CLOCK LOGBOOK
#+PROPERTIES: CLOCK_INTO_DRAWER 2

#+TODO: TODO | DONE WONTFIX

#+OPTIONS: toc:nil
##+OPTIONS: toc:t  tags:not-in-toc
#+OPTIONS: ^:{}
#+OPTIONS: tasks:todo
##+OPTIONS: num:nil
#+OPTIONS: H:4 num:t
##+OPTIONS: \n:nil @:t ::t |:t -:t f:t *:t <:t
##+OPTIONS: TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil

##+EXPORT_SELECT_TAGS: export
##+EXPORT_EXCLUDE_TAGS: noexport

#+LaTeX_CLASS_OPTIONS: [12pt,pdftex]
##+LaTeX_CLASS_OPTIONS: [paralist]
##+LATEX_HEADER: \newcommand{\sectionbreak}{\clearpage}

;; File variables

;; Local Variables:
;;   mode: org
;;   ispell-check-comments: t
;;   coding: utf-8
;;   eval: (flyspell-mode 1)
;;   ispell-local-dictionary: "en_CA"
;; End:

;;
;; LocalWords:



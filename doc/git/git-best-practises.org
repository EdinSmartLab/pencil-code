#+TITLE: Git Best Practises

#+LaTeX: \thispagestyle{empty}

#+begin_abstract
#+LaTeX: \noindent%
Tips and recommendations for using Git with the Pencil code:
- Don't panic.
- Don't pull from the remote branch into the tracking branch.
- Make the git history a good narrative.
#+end_abstract


* Operative Summary

  Here is the bottom line of this document.

  1. Decide whether you want to rebase or merge your local changes into
     upstream (typically the /origin/master/ branch).

     a. Rebase: Use '=git pull --rebase=' to get upstream changes into you
        local tracking branch (typically /master/).

     b. Merge: Do /not/ merge upstream into your tracking branch like this:
        #+BEGIN_SRC sh
        git merge origin/master  # DON'T!
        #+END_SRC
        because that breaks the SVN bridge and makes it quite difficult to
        understand the history of commits.

        Instead, merge your changes into upstream, either manually or
        using
        #+BEGIN_SRC sh
        git pc reverse-merge  # DO THIS INSTEAD
        #+END_SRC

  2. Think about using feature branches for logic units that cover more
     than a few commits.


* Prerequisites

  This text is not an introduction to Git – there are many Git tutorials
  available on the web, and I will assume that you already know the basic
  operations.

  Let us recall a few important concepts for the discussion to follow.


** What is Git?

   Git is a flexible version-control system that is well-suited for
   software development, be it with a centralized server (Github, in our
   case), or in a completely decentralized setting.


** What is a Git repository?

   A Git repository is a set of unique commits that form a
   [[https://en.wikipedia.org/wiki/Directed_acyclic_graph][directed acyclic graph]] (DAG) like this:
   #+begin_example
     A---B---C---D---E---F--- master
          \     /     \
           G---H       I---J--- feature
   #+end_example

   We say that E is a /child/ of D, and that D has two
   /parents/, C and H.
   The /ancestors/ of D consists of A, B, C, G, and H.
   The /descendants/ of D are E, F, I, and J.

   If you know how to read this diagram, you know enough about DAGs for
   our purposes.[fn:1]


[fn:1]You get extra credits if you can tell which of the commits A, E and
G belong to branch /feature/.


** What is a commit?

   A commit typically represents a state of the file tree (the directory
   tree you get by checking out a revision), together with its complete
   commit ancestry.
   So you get different commit ids (represented as hexadecimal SHA1 hash
   codes) if you
   - commit a change, commit the inverse of that change, and commit the
     original change again;
   - change the commit message of your last commit (with =‘git commit
     --amend’=);
   - take some part of the commit graph and attach it somewhere else
     (=‘git rebase’=);
   - make any change to a commit that is an ancestor of the commit in
     question.


** The narrative metaphor

   In many respects the commit history we create with Git is a /narrative/
   that tells us (and others) how the code evolved to its current state.

   Indeed, committing changes has a lot in common with telling a story,
   and that story can be interesting or boring, it can be presented in a
   logical way or totally confusing, even if the final code in both cases
   is the same.

   And while there are different styles of telling the story well, a badly
   told narrative will make us all suffer.
   So please think about the logical order in which your changes make most
   sense and formulate and format your log messages appropriately.[fn:2]


[fn:2]The first line of your commit message is a heading summarizing what
has happened.
The second line is traditionally kept empty, and more details can follow
on lines 3, 4, 5, etc. of the log message.


** The different levels of a Git repository's state

   There are (at least) four different variants of the /Pencil Code/ that
   you are interacting with:
   1. The upstream branch that you occasionally update by querying the
      server (there could be several upstream branches, but not for us).
      You cannot directly commit to this branch, because its purpose is to
      represent the last state of the server branch you /fetched/.
   2. Your tracking branch.
      This is where [...]
   3. The /index/ where changes are recorded before they get committed to
      your local branches.
   4. The file system.

   [Many possibilities for discord, but not that bad...]


** Atomicity

   Git commands tend to be focused on one task.
   As a consequence, what the user perceives as one logical step may
   require two or three consecutive command calls.
   This helps in understanding what you are doing, and when something
   goes wrong you know where exactly the problem occurred.

   However, if you prefer to combine several elementary git operations
   into one command call (say, committing and pushing), or don't want to
   type the same command-line options over and over again, you can (of
   course) create a shell script, or you can define a /Git alias/.
   For example, after running
   #+begin_src sh
     git config --global alias.where 'rev-parse --short=12 HEAD'
   #+end_src
   you will have a new git command ‘git where’ that tells you the SHA1
   hash of the current HEAD commit.
   Git aliases automatically inherit some niceties like command completion
   or a =--help= option.

   As in other contexts, it is a virtue to not become too dependent on
   such helpers, lest you forget what you are doing, have a hard time
   communicating with others and feel lost in environments where those
   helpers are missing.

   The /Pencil Code/ comes with a =‘git pc’= script that provides some
   combined operations.
   Run =‘git pc -h’= to get a list of available sub-commands.


* Joining different lines of development
  <<Section:Joining-lines-of-development>>

  In a community coding project like the /Pencil Code/, we will
  frequently have a situation like this:
  #+begin_example
     A---B---C--- branch1
          \
           F---G--- branch2
  #+end_example
  where different (diverging) commits have been made on different
  branches (very often, these branches are the remote branch
  /origin/master/ and the local tracking branch /master/), and we want to
  integrate both lines of development into one.

  Git offers two different techniques to achieve that goal: /merging/ and
  /rebasing/.


** What is merging?
   <<Merge>>

   A /merge/ commit adds a new connection to parts of the Git graph.
   For example, if we have the following situation
   #+begin_example
     A---B---C--- master
          \
           F---G--- feature
   #+end_example
   and want to bring the changes from branch /feature/ to /master/, we
   can merge /feature/ into /master/ and get
   #+begin_example
     A---B---C---D--- master
          \     /
           F---G--- feature
   #+end_example

   In the pure DAG sense, the two parents C and G of the merge commit D
   are completely equivalent, but for reasons discussed [[below]], we want to
   make sure we merge /feature/ into /master/ (so C is the /first parent/
   and G is the /second parent/), not the other way around.

   You remember our narrative metaphor?
   If you always /merge/ your commits or groups of commits because you
   don't want to change history, you are narrating in a diary or
   chronicler's style.


** What is rebasing?
   <<Rebase>>

   In the example above, we have a second option to bring the feature
   branch's changes into master, by creating new commits that contain
   those changes:
   #+begin_example
     A---B---C---D---F'---G'--- master, feature
   #+end_example
   Immediately after this, both /master/ and /feature/ point to the same
   commit G', but will may change as you continue to commit, e.g.
   #+begin_example
     A---B---C---D---F'---G'---H--- master
                           \
                            I--- feature
   #+end_example

   Rebasing is not an exclusive option.
   Even if you routinely rebase your local changes, you will want to
   merge longer-lived feature branches.

   In terms of narrating, /rebasing/ suggests letter style, where you
   bring facts into logical frames and order them accordingly (because it
   is too hard to find readers for stream-of-consciousness letters).


** Pros and cons

   Here is the decision matrix for merging vs. rebasing

   | Criterion                 | Merge        | Rebase           |
   |---------------------------+--------------+------------------|
   | Resulting graph structure | More complex | Simpler          |
   | History                   | Preserved    | Modified         |
   | Safety                    | Safer        | Less safe [fn:3] |

   In short, use merging when you are afraid – but you know from
   Sec.\nbsp{}\ref{Section-dont-panic} that you needn't be afraid.


[fn:3] Less safe in the sense that conflicts can put you in a
detached-head state.


*** Graph structure

    Every merge commit increases the connectivity of the commit graph by
    one[fn:4].
    A rebase, by contrast, does not change the connectivity and leads to a
    more linear history.


[fn:4] Or even more than one, in the case of an /octopus merge/.
     But those are somewhat exotic.


*** Rewriting history

    In our rebase example above, the commits F and G were transformed
    into F' and G'.
    In the simplest case, both sets of commits represent exactly the same
    difference of the file tree.
    But if you had to fix conflicts, this is no longer the case, and you
    appear to have lost the original change G by pretending that you were
    applying a change G' in the first place.[fn:5]
    Even if there are no conflicts during the rebase, the state G' is
    completely new, and there is no guarantee that it will
    e.g.\nbsp{}compile.

[fn:5] But of course this is not true: you can use =‘git reflog’= and
friends to view your original changes, see
Sec.\nbsp{}\ref{Section-almost-panicking}.
And you will no longer be interested in the original change once
the new version gets part of the Git narrative.


    Once you accept the idea that you can change history, you can use it
    to write meaningful commit messages while you are in the right set
    of mind (i.e. /before/ you test your changes, because after testing
    it is harder to remember what you were doing in the first place).
    Or you can rewrite history to fix a recent commit (code and message),
    or to combine commits in order to get a more readable history.

*** The worst thing that can happen

    If you have conflicts, rebasing can bring your sandbox [explain that
    name, or use another word] into a state where you are not on any
    branch (/detached head/).
    This is not really something to worry about:
    Just fix the conflicts and do '=git rebase --continue=' to finish the
    rebase; and in case you get lost, do '=git rebase --abort=' and start
    afresh.
    Even if you get completely lost and resort to measures like
    '=git reset=', [[What to do when you think you're lost][you needn't be afraid]] to lose history.


* Don't panic
  \label{Section-dont-panic}

  or /What to do when you think you're lost/

  Git will try hard to preserve your changes:[fn:6]

  - Any changes you committed will be part of the [[git reflog][/reflog/]] for at least
    two weeks[fn:7], even if you change or abandon them.

  - Uncommitted changes to git-controlled-files will only get overwritten
    if you run one of the commands
    - =git checkout <file-or-directory>=
    - =git reset --hard=
    - And of course any non-git commands that change files

  - Files unknown to Git will only get lost with
    - =git clean=
    - Again, any non-git commands that change files


[fn:6]There are corner cases where other git commands (like
  =git stash --include-untracked=) call =git clean=, which can in
  principle [[http://blog.icefusion.co.uk/git-stash-can-delete-ignored-files-git-stash-u/][lead to data loss]].
  However, this should only concern files that match your =.gitignore=
  patterns, and if that is the case for any file you care about, you have
  been asking for trouble beforehand.


[fn:7]Unless you explicitly decide otherwise.


  Table \ref{Table:How-to-lose-changes} summarizes this discussion.

#+label: Table:How-to-lose-changes
#+caption: How to lose changes with git
   | /Changes/                                   | /How they can get lost/               |
   |---------------------------------------------+---------------------------------------|
   | Changes committed to git                    | Not at all, unless you insist [fn:8]  |
   |---------------------------------------------+---------------------------------------|
   | Uncommitted changes to git-controlled files | =git checkout <file-or-directory>=    |
   |                                             | =git reset --hard=                    |
   |                                             | Non-git commands                      |
   |---------------------------------------------+---------------------------------------|
   | Files unknown to Git                        | =git clean=                           |
   |                                             | Non-git commands                      |


[fn:8] Leaving important Git commits dangling (≈ unused) for more than two
weeks counts as insisting on data loss.


** I'm almost panicking …
   \label{Section-almost-panicking}

#+LaTeX: \emph{
   … for I'm afraid something got lost, although I know this is not the
   case because I stayed away from the commands in Table
   \ref{Table:How-to-lose-changes}.
#+LaTeX: }

   \bigskip

   Here is how to see almost every change[fn:9] that was ever[fn:10]
   known to git:
   #+begin_src sh
     gitk --reflog --all
     # or
     tig --reflog --all
     # or, without graphics,
     git reflog --all --glob='stash*'
   #+end_src

   If you want to also see dropped stashes, you can use
   #+begin_src sh
     git pc panic -v
   #+end_src


[fn:9] This will not show dropped stashes or stashes older than the last
one (but those are still accessible).


[fn:10] Redefining “ever” = “in the last two weeks” for dangling commits.


* Best practices

** Don't merge upstream into your tracking branch
   \label{S-developing-on-master}

   Suppose you just started developing code on /master/.
   Your branches look like this (A and B are commits, the `o' is just
   a visual connector):
   #+begin_example
     --A---B-----  origin/master (remote branch)
            \
             o---  master (local tracking branch)
   #+end_example


   \bigskip

   Despite its name, the /remote branch/ exists only on your computer.
   It represents what is known about a branch called /master/ on the
   server and serves for synchronization with the server.
   You cannot directly commit to this branch.

   The tracking branch reflects how you would like the server branch to
   look like.[fn:11]


   \bigskip


   Now you commit some changes X, Y to your local tracking branch:
   #+begin_example
     --A---B----------  origin/master
            \
             X---Y----  master
   #+end_example
   and want to push them to the server.
   If the server is still at commit B, this will result in
   #+begin_example
     --A---B---X---Y-----  origin/master
                    \
                     o---  master
   #+end_example

   However, if somebody has committed changes to the server before you
   push, you will get an error message[fn:15]:
   #+begin_example
     To [...]
      ! [rejected]        master -> master (fetch first)
     error: failed to push some refs to [...]
     hint: Updates were rejected because the remote contains work that you do
     hint: not have locally. This is usually caused by another repository pushing
     hint: to the same ref. You may want to first integrate the remote changes
     hint: (e.g., 'git pull ...') before pushing again.
     hint: See the 'Note about fast-forwards' in 'git push --help' for details.
   #+end_example

   Before you can fix the problem, you need to =git fetch= to update the
   remote branch:
   #+begin_example
     --A---B---C---D---E--  origin/master
            \
             X---Y--------  master
   #+end_example

   Your task is to bring the two lines of development together, and you can
   either do this [[Rebase][using rebase]], or [[Merge][using merge]].


[fn:11]And if that is not compatible with the server's latest history, you
modify the tracking branch until it is.


[fn:15]Do you see the ellipses in the suggested '=git pull ...=' command?
Git did /not/ say you should run just =‘git pull’= without any arguments.


*** Alternative 1: Rebase

   Rebasing is straight-forward, you run
   #+begin_src sh
     git rebase origin/master
   #+end_src
   if necessary deal with conflicts (that will temporarily throw your
   repository into a headless state) and end up with
   #+begin_example
     --A---B---C---D---E-----------  origin/master
                        \
                         X'---Y'---  master
   #+end_example
   You have changed your commits by turning them into descendants of E (and
   possibly by including solutions for conflicts) and you can now push to
   get
   #+begin_example
     --A---B---C---D---E---X'---Y'----  origin/master
                                 \
                                  o---  master
   #+end_example
   As mentioned earlier, this approach gives you a linear history similar
   to what you know from /Subversion/.

   \bigskip

   While it is completely feasible to first fetch, then rebase, you can
   have both in one command:
   #+begin_src sh
     git pull --rebase
   #+end_src
   This is equivalent to ~git fetch; git rebase origin/master~, so this is
   exactly what we need[fn:12]
   See also [[https://asciinema.org/a/dauj562l4uwr7bpyohqyewkj5][Tobi's screencast]] where he demonstrates a variant of that
   approach.

   \bigskip

   To summarize this subsection:
   To push your committed changes, run
   #+begin_src sh
     git pull --rebase
     git push
   #+end_src
   (possibly in connection with ~rebase.autostash=true~),
   or maybe
   #+begin_src sh
     git pc pull-and-rebase
     git push
   #+end_src
   and life will be beautiful.


[fn:12]You can even set the =--rebase= option via your git configuration,
using\\
\noindent\qquad\qquad  =git config --global branch.master.rebase true=\\
\noindent\qquad\qquad  =git config --global branch.autoSetupRebase always=\\
and henceforth when you type =‘git pull’=, you will in fact do
=‘git pull --rebase’=.

However, I recommend against using these options, because tacitly changing
the behaviour of commands is a great source of confusion.
Sooner or later you will work on a system where you have not set these
flags (e.g. because you forgot, or you are helping somebody else).
Without thinking twice, you will type =‘git pull’=, then =‘git push’=,
and, voilà: after half year of disciplined commits by everybody, you
managed to break the SVN bridge again.


*** Alternative 2: Merge the other way around

   Alternatively, we /can/ merge the two branches together.
   Here the discussion gets more complicated, so we moved it
   to Appendix \ref{Section-which-way-to-merge}.

   The take-home message is to merge not the remote branch into the
   tracking branch:
   #+begin_src sh
     git merge origin/master  # DON'T DO THIS
   #+end_src
   but rather the other way around, because
#+LaTeX: \emph{%
   the commit you push must not be a merge of /origin/master/ into
   /master/.
#+LaTeX: }

   Getting this typically right involves some temporary branch or tag and
   a =git reset=, but as an alternative, you can use our
   #+begin_src sh
     git pc reverse-merge origin/master  # DO THIS INSTEAD
   #+end_src

   \bigskip

   The higher-level rule behind this is as follows:
   #+begin_quote
   #+LaTeX: \setlength{\fboxsep}{8pt}
   #+LaTeX: \fbox{%
   #+LaTeX:     \begin{minipage}{0.7\textwidth}%
   #+LaTeX:     \slshape
   \textbf{Rule 1:}
   The first-parent history of /origin/master/ should correspond to the
   order in which the commits appeared on the server and may thus only be
   appended to.
   #+LaTeX:     \end{minipage}%
   #+LaTeX: }
   #+end_quote
   If this rule is violated, tools like the GitHub SVN bridge or the
   commit emails will fail, and history will generally become misleading.


** Feature branches

   - When you are working on one topic and expect more than a
     handful[fn:13] of changes, consider using a /feature branch/.

   - When you are collaborating on a topic with somebody else and your
     changes are not yet ready for the others, use a feature branch.


[fn:13] Even just two or three commits may be enough to go for a feature
branch if that improves the narrative.


  To work with a feature branch, just go to the latest commit of /master/
  (the later you start the branch, the fewer conflicts you will create),

  #+begin_src sh
    git checkout master
    git pull --rebase
  #+end_src
  and create the branch
  #+begin_src sh
    git checkout -b cool-new-feature
  #+end_src

  \bigskip

  If that branch is long-lived, you will want to occasionally merge
  /master/ into it:[fn:14]
  Run
  #+begin_src sh
    git fetch origin
    git stash  # if you have uncommitted local changes
  #+end_src
  to update your knowledge of the server's master branch.

  Then do
  #+begin_src sh
    git checkout master            # check out your local tracking branch ...
    git pull --rebase              # ... and bring it up to date

    git checkout cool-new-feature  # go back to your feature branch
    git merge master               # do the actual merge
  #+end_src
  There are some shorter variants to this procedure. You can use our
  =‘git pc’= script like this:
  #+begin_src sh
    git pc ff-update master  # bring master up-to-date
    git merge master         # do the actual merge
  #+end_src
  or you could directly merge the remote branch
  #+begin_src sh
    git merge origin/master
  #+end_src
  although this is less common than merging the local tracking branch.

  After merging, don't forget to
  #+begin_src sh
    git stash pop
  #+end_src
  if you have stashed changes before you merged.

  \bigskip

  When your branch is ready for merging back, you do
  #+begin_src sh
    git checkout master
    git pull --rebase           # bring master up-to-date
    git merge cool-new-feature
    [test]
    git push
  #+end_src

  The topology now looks like this:
  #+begin_example
    --A---B---C---D---E---F---G---H---I--- master
       \               \             /
        N---O---P---Q---R---S---T---U      feature
  #+end_example

  \bigskip

  What if that push failed due to somebody committing new changes
  upstream?

  No problem.
  We tag the first merge attempt and merge that tag to the updated
  upstream branch:
  #+begin_src sh
    # remember, we are on master
    git push   # fails: "! [rejected] master -> master (fetch first)"

    git tag previous-merge-of-cool-new-feature
    git fetch                       # update origin/master
    git reset --hard origin/master  # update local master branch
    git merge previous-merge-of-cool-new-feature
    [test]
    git push
  #+end_src

  The narrative now says:
  We have tried to merge /cool-new-feature/ into master, but failed to
  push that, so we then merged that first merge into master and pushed.
  That may be more detail than we wanted (and more steps than we
  anticipated), but describes exactly what happened.

  #+begin_example
    --A---B---C---D---E----F-----G----H---X---Y--- master
       \               \               \     /
        \               \               I---o
         \               \             /
          N---O---P---Q---R---S---T---U            feature
  #+end_example


  \bigskip


   Using /feature branches/ with appropriate granularity, you tell the
   story in a kind of novelist style.
   Actually, the metaphor falls short in this case, as your audience has
   the choice to read just a synopsis (by looking at the main branch only)
   or go into small details (reading the commits inside the feature
   branches).


[fn:14] This does /not/ violate our rule
`[[Don't merge upstream into your tracking branch][don't merge upstream into your local tracking branch]]'.



#+Latex: \appendix



* Which way to merge
  \label{Section-which-way-to-merge}

  Consider the situation from Sec. \ref{S-developing-on-master}, where
  you want to join your line of development with what happened n the
  server:
  #+begin_example
    --A---B---C---D---E--  origin/master
           \
            X---Y--------  master
  #+end_example

  It is tempting to just call (after the =git fetch=)
  #+begin_src sh
    git merge origin/master  # DON'T DO THIS
  #+end_src
  which would give you the following repository structure
  #+begin_example
    --A---B---C---D---E-----  origin/master
           \           \
            X-----Y-----M---  master
  #+end_example
  This doesn't look bad, so you now push /master/ to the server and get
  #+begin_example
    --A---B---C---D---E---M----  origin/master
           \             / \
            X-----------Y   o--  master
  #+end_example

  Topologically, that is exactly what we want.
  But there is more to a git repository than pure topology of the
  directed acyclic graph: there is an order in parentage.
  Y is the /first parent/ of the merge commit M, while E is the /second
  parent/:[fn:15]
  #+begin_example
                        2
    --A---B---C---D---E---M-----  origin/master
           \             /1\
            X-----------Y   o---  master
  #+end_example

  Straightening out the first-parent connection, this can be rearranged as
  #+begin_example
                    1
    --A---B---X---Y---M-----  origin/master
           \         /2 \
            C---D---E   o---  master
  #+end_example
  and indeed this is what many tools will show you.[fn:16]

  For example, commands like =gitk --first-parent= (or simply =git log
  --first-parent=), give
  #+begin_example
    --A---B---X---Y---M-----  origin/master
               \     / \
                        o---  master
  #+end_example
  which suggests that the main chain (= first-parent lineage) of commits
  on the server has disruptively changed from
  #+begin_example
    --A---B---C---D---E-----
  #+end_example
  to
  #+begin_example
    --A---B---X---Y---M-----
  #+end_example

  If the SVN bridge has to rely on first-parent lineage between commits to
  create its linear history, such a reinterpretation leads to a new SVN
  repository structure that is not compatible with what we had before.
  Hence, it is not surprising that such merges cause troubles with the SVN
  bridge:
  #+begin_example
    $ svn commit <file>
    svn: E160024: Transmission failed (Details follow):
    svn: E160024: resource out of date; try updating
  #+end_example


[fn:15]My notation in the graph is adopted from
   [[http://git-blame.blogspot.de/2015/03/fun-with-non-fast-forward.html][Junio Hamano's Blog]].
   Another good discussion on the importance of first-parent history can
   be found on the [[http://devblog.nestoria.com/post/98892582763/maintaining-a-consistent-linear-history-for-git][Nestoria Dev Blog]].


[fn:16]Including the [[https://github.com/pencil-code/pencil-code/network][GitHub network graph]], gitk (to some extent) and the
GitHub SVN bridge.


  \bigskip

  So is it really wrong to merge?
  Not if you merge the right way around.
  You need to create a merge commit where the latest upstream commit (E
  in our example) is the first parent, and the tracking-branch commit (Y)
  is the second parent.

  How to do this is left as an exercise to the reader.
  It is not very tricky, but for convenience we have a =git-pc= command
  #+begin_src sh
    git pc reverse-merge origin/master  # DO THIS INSTEAD
  #+end_src
  that gives you exactly the desired structure:
  #+begin_example
                        1
    --A---B---C---D---E---M-----  origin/master
           \             /2\
            X-----------Y   o---  master
  #+end_example
  which you can push without violating our Rule 1.

  Apart from avoiding problems with the SVN bridge, merging the right way
  around will also lead to a much more meaningful history.
  Consider the following real-life example:[fn:17]

#+LaTeX: \includegraphics[width=.97\linewidth]{git-wrong-history.pdf}

#+begin_HTML
<pre>
  A   o           add new time step calculation for slope limited diffusion
  B   o           Added comments about which line will not work
  C   M─┐         Merge branch 'master' of https://github.com/pencil-code/pencil-code
  D   │ o         Revised data to account for correction to chi-therm
  B   │ o         Lets see if the new IO modules work everywhere as expected...
  D   │ M─┐       Merge branch 'master' of https://github.com/pencil-code/pencil-code
  B   │ │ o       We explicitly want to allow missing namelists
  D   │ M─│─┐     Merge branch 'master' of https://github.com/pencil-code/pencil-code
  A   │ │ o─┘     fixed some errors
  D   │ M─│─┐     Merge branch 'master' of https://github.com/pencil-code/pencil-code
  A   │ │ o─┘     removed some doubling of some subroutine
  A   │ │ o       more on slope limited diffusion
  E   │ │ M─┐     Merge branch 'master' of https://github.com/pencil-code/pencil-code
  F   │ │ │ o     added Hill vortex rain as forcing
  B   │ │ │ M─┐   Finally fixed the last still broken autotest
  B   │ │ │ │ o   Finally fixed the last still broken autotest
  A   │ │ │ o │   More correction and additions for the slope limited diffusion,
  B   │ │ │ o─┘   Removed "array temporaries", see also 2a73f3cea323
  G   │ │ │ o     added a phase to enforced vertical shear profile;
  E   │ │ o │     Adding components of the current helicity tensor.
  D   │ o │ │     thermo hydrostatic equilibrium ISM still under construction
  C   o │ │ │     pc_meanfield_collect: Fixed some bugs and removed line writes
</pre>
#+end_HTML

  So, did users A, B and G really work on the same feature branch to add
  phase to the shear profile, remove array temporaries and to correct
  slope limited diffusion?
  And did those commits get merged in a commit that claims to have fixed
  the last broken autotest?

  The true story must have been more like this:

#+LaTeX: \includegraphics[width=.97\linewidth]{git-better-history.pdf}

#+begin_HTML
<pre>
  A   o          add new time step calculation for slope limited diffusion
  B   o          Added comments about which line will not work
  C   M─┐        Merge one commit into master
  D   o │        Revised data to account for correction to chi-therm
  B   o │        Lets see if the new IO modules work everywhere as expected...
  D   M─│─┐      Third try at merging equilibrium in to master
  B   o │ │      We explicitly want to allow missing namelists
  D   │ │ M─┐    Second try at merging hydrostatic equilibrium into master
  A   o─│─┘ │    fixed some errors
  D   │ │   M─┐  First try at merging hydrostatic equilibrium into master
  A   o─│───┘ │  removed some doubling of some subroutine
  A   o │     │  more on slope limited diffusion
  E   M─│─┐   │  Merge current helicity tensor into master
  F   o │ │   │  added Hill vortex rain as forcing
  B   M─│─│─┐ │  Merge fix for last broken autotest
  B   │ │ │ o │  Finally fixed the last still broken autotest
  A   o │ │ │ │  More correction and additions for the slope limited diffusion,
  B   o─│─│─┘ │  Removed "array temporaries", see also 2a73f3cea323
  G   o │ │   │  added a phase to enforced vertical shear profile;
  E   │ │ o   │  Adding components of the current helicity tensor.
  D   │ │ │   o  thermo hydrostatic equilibrium ISM still under construction
  C   │ o │   │  pc_meanfield_collect: Fixed some bugs and removed line writes
</pre>
#+end_HTML

  Most of the development happened on the main line, but occasionally
  somebody had a change that needed to get merged into that line, because
  other commits got pushed first.

  And indeed something like this is how =tig= would have drawn the graph,
  had all of the merges been from tracking-branch into the remote branch
  and not the other way around.


[fn:17]The output was obtained using =tig= on the Pencil Code repository,
removing many commits, shortening and mildly anonymizing the commits.


  \bigskip

  To summarize this section:
#+LaTeX: \emph{
  When developing on /master/, if you cannot directly push your changes
  due to upstream commits, either use /rebase/, or use /git pc
  reverse-merge/.
#+LaTeX: }


* Put this somewhere                                               :noexport:



** Autostash and git 2.6

** Use gitk (or '=tig=' or some variant of '=git log --graph=')

** What to avoid

   - Rewrite history that is already on the server
     - You can only rewrite (or rebase) commits in the range between
       /origin/master/ and /master/:
       #+begin_src sh
         gitk origin/master..master
       #+end_src


   - Don't push your personal tags [but not so important, we can delete
     them later]



* Org configuration                                   :noexport:ARCHIVE:

#+AUTHOR: Wolfgang Dobler
#+EMAIL:
#+DESCRIPTION:
#+KEYWORDS:
#+LANGUAGE: en

##+STARTUP: content
#+STARTUP: showall

##+ARCHIVE: ::* Archive

#+DRAWERS: HIDDEN PROPERTIES CLOCK LOGBOOK
#+PROPERTIES: CLOCK_INTO_DRAWER 2

#+TODO: TODO | DONE WONTFIX

##+OPTIONS: toc:nil
#+OPTIONS: toc:t  tags:not-in-toc
#+OPTIONS: ^:{}
#+OPTIONS: tasks:todo
##+OPTIONS: num:nil
#+OPTIONS: H:4 num:t
##+OPTIONS: \n:nil @:t ::t |:t -:t f:t *:t <:t
##+OPTIONS: TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil

##+EXPORT_SELECT_TAGS: export
##+EXPORT_EXCLUDE_TAGS: noexport

#+LaTeX_CLASS_OPTIONS: [12pt,pdftex]
##+LATEX_HEADER: \newcommand{\sectionbreak}{\clearpage}
#+LaTeX_HEADER: \usepackage{listings}

;; File variables

;; Local Variables:
;;   mode: org
;;   ispell-check-comments: t
;;   coding: utf-8
;;   org-latex-listings: listings
;;   org-latex-listings-options: (("frame" "single") ("basicstyle" "\\ttfamily\\footnotesize"))
;;   eval: (flyspell-mode 1)
;;   ispell-local-dictionary: "en_CA"
;; End:

;;
;; LocalWords:



#  LocalWords:  rebase
